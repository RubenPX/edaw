var edaw=function(i){"use strict";var F=Object.defineProperty;var G=(i,c,d)=>c in i?F(i,c,{enumerable:!0,configurable:!0,writable:!0,value:d}):i[c]=d;var u=(i,c,d)=>(G(i,typeof c!="symbol"?c+"":c,d),d);const c={RoundedBorder:o=>`border-left: 2px solid ${o}; border-right: 2px solid ${o}; padding: 0 4px; border-radius: 5px; `},d={green:"color: #0d0; ",blue:"color: #0af; ",red:"color: #f20; ",orange:"color: #F80; ",purple:"color: #d602ee; "},g=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?"W":"C",m={sendMsg:[`%c${g}⮞`,d.orange+c.RoundedBorder("#F80")],reciveMsg:[`%c${g}⮜`,d.green+c.RoundedBorder("#0d0")],Error:[`%c${g}⭙`,d.red+c.RoundedBorder("#f20")],ObserverRegister:[`%c${g}⭘`,d.purple+c.RoundedBorder("#d602ee")],ObserverUnRegister:[`%c${g}⮾`,d.purple+c.RoundedBorder("#d602ee")]},f="padding-left: 5px; padding-right: 5px; padding-top: 2px;",D="background-color: #38f; border-radius: 100px; color: #000;",R="background-color: #492; border-radius: 100px; color: #000;",y="background-color: #fa0; border-radius: 100px; color: #000;",O="background-color: #f53; border-radius: 100px; color: #000;";class W{static info(e,r=""){return e instanceof Array?["%c"+e.join(" | "),`${f} ${D}`,r]:["%c"+e,`${f} ${D}`,r]}static warn(e,r=""){return e instanceof Array?["%c"+e.join(" | "),`${f} ${O}`,r]:["%c"+e,`${f} ${O}`,r]}static yellow(e,r=""){return e instanceof Array?["%c"+e.join(" | "),`${f} ${y}`,r]:["%c"+e,`${f} ${y}`,r]}static succes(e,r=""){return e instanceof Array?["%c"+e.join(" | "),`${f} ${R}`,r]:["%c"+e,`${f} ${R}`,r]}}let v;const U=new Uint8Array(16);function C(){if(!v&&(v=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!v))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return v(U)}const n=[];for(let o=0;o<256;++o)n.push((o+256).toString(16).slice(1));function j(o,e=0){return n[o[e+0]]+n[o[e+1]]+n[o[e+2]]+n[o[e+3]]+"-"+n[o[e+4]]+n[o[e+5]]+"-"+n[o[e+6]]+n[o[e+7]]+"-"+n[o[e+8]]+n[o[e+9]]+"-"+n[o[e+10]]+n[o[e+11]]+n[o[e+12]]+n[o[e+13]]+n[o[e+14]]+n[o[e+15]]}const $={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function S(o,e,r){if($.randomUUID&&!e&&!o)return $.randomUUID();o=o||{};const t=o.random||(o.rng||C)();if(t[6]=t[6]&15|64,t[8]=t[8]&63|128,e){r=r||0;for(let s=0;s<16;++s)e[r+s]=t[s];return e}return j(t)}class l{constructor(e,r,t){u(this,"id",S());u(this,"returnData");u(this,"error",!1);u(this,"resolved",!1);this.context=e,this.method=r,this.params=t}static regenerate(e){return new l(e.context,e.method,e.params)}static parseMessageEvent(e){const{id:r,context:t,method:s,params:b,...a}=e.data;if(t&&s){const h=new l(t,s,b);return h.id=r,h.resolved=a.resolved??!1,h.returnData=a.returnData??void 0,a.error&&(h.error=a.error),h}else{const h=new l("","");return h.error=!0,h.returnData=e.data,h}}static parseErrorEvent(e){const r=new l("","");return r.error=!0,r.returnData=e,r}}class E{}u(E,"production",!1),u(E,"verbose",{worker:{observe:!1,unObserve:!1,showIn:!1,showOut:!1},browser:{observe:!1,unObserve:!1,showIn:!1,showOut:!1}});const p=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;class B{constructor(e){u(this,"logger",E);u(this,"isWorker",typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope);u(this,"handlers",[]);this.manager=e,e.addEventListener("message",r=>this.onWorkerMessage(r)),e.addEventListener("error",r=>this.onWorkerError(r)),e.addEventListener("messageerror",r=>this.onWorkerMessage(r))}onWorkerMessage(e){const r=l.parseMessageEvent(e);(p&&this.logger.verbose.worker.showIn||!p&&this.logger.verbose.browser.showIn)&&console.debug(...m.reciveMsg,{id:{id:r.id},context:r.context,method:r.method,returnData:r.returnData}),this.publish(r)}onWorkerError(e){const r=l.parseErrorEvent(e);console.error(...m.Error,{ev:e}),this.publish(r)}postMessage(e,r=!1){r&&(e.resolved=!0),(p&&this.logger.verbose.worker.showOut||!p&&this.logger.verbose.browser.showOut)&&console.debug(...m.sendMsg,{id:{id:e.id},context:e.context,method:e.method,returnData:e.returnData}),this.manager.postMessage(e)}publish(e){if(e.resolved)return this.dispatchEvent(e);const r=Object.values(this.routes).filter(t=>t.contextName===e.context);r.length!==0?r.forEach(async t=>{try{e.returnData=(await t.runEvent(this,e)).returnData}catch(s){e.error=!0,e.returnData=s,s instanceof Error&&(e.returnData={message:s.message,stack:s.stack}),s instanceof Object&&(e.returnData={...s,...e.returnData})}this.postMessage(e,!0)}):(e.error=!0,e.returnData=new Error("Route not found"),this.postMessage(e,!0))}dispatchEvent(e){const r=this.handlers.filter(t=>t.msgEvent.context===e.context&&t.msgEvent.method===e.method);for(const t of r)t.clbk(e)}offMessage(e){this.handlers=this.handlers.filter(r=>r.msgEvent.id!==e.id),(p&&this.logger.verbose.worker.unObserve||!p&&this.logger.verbose.browser.unObserve)&&console.debug(...m.ObserverUnRegister,e.id)}onMessage(e,r){const t=e;return this.handlers.push({msgEvent:t,clbk:r}),(p&&this.logger.verbose.worker.observe||!p&&this.logger.verbose.browser.observe)&&console.debug(...m.ObserverRegister,t.id,{context:e.context,method:e.method}),t}observe(e,r){const t=new l(e.context,e.method,e.params);return this.onMessage(t,r)}postReturn(e,r,t){const s=new l(e,r,t),b=new Promise((a,h)=>{this.onMessage(s,w=>{s.id===w.id&&(w.error?h(w.returnData):a(w),this.offMessage(s))})});return this.postMessage(s),b}async postInitialize(){console.groupCollapsed(`${p?"Worker":"Client"} route registers`),Object.entries(this.routes).forEach(([r,t])=>{Object.entries(t.EventRoutes).forEach(([s,b])=>{console.debug(...W.info("routeRegister",{context:t.contextName,method:s}))})}),console.groupEnd();const e=new l("root","initialized");e.returnData=this.getClientRoutes(),e.resolved=!0,this.postMessage(e,!0)}getClientRoutes(){return Object.entries(this.routes).reduce((e,[r,t])=>(e[r]=t.getRoutes(),e),{})}}class x{constructor(e,r){this.repo=e,this.run=r}async runMethod(e,r){if(typeof this.repo=="number"&&isNaN(this.repo))throw new Error("Repository is not initialized");return await this.run({repo:this.repo,params:e.params,bus:r,evMsg:e})}static prepareEvent(e){return r=>new x(r??NaN,e)}}class A{async runEvent(e,r){const t=Object.entries(this.EventRoutes).find(([b])=>b===r.method);if(!t)throw new Error("Method not found");const s=t[1];return r.returnData=await s.run({repo:this.repos,evMsg:r,params:r.params,bus:e}),r}getRoutes(){return Object.entries(this.EventRoutes).reduce((e,[r,t])=>(e[r]={context:this.contextName,method:r},e),{})}}class I{constructor(e,r){u(this,"filters",{});u(this,"sorter",null);this.route=e,this.client=r}setFilter(e,r){this.filters[e]=r}removeFilter(e){this.filters=Object.fromEntries(Object.entries(this.filters).filter(r=>r[0]!==e))}sort(e){this.sorter=e}getFilters(){return this.filters}getSort(){return this.sorter}}class k{constructor(e){this.builder=e}observe(e){let r;const t=a=>{a.error&&r?r(a):e(a)},s=this.builder.client.observe({context:this.builder.route.context,method:this.builder.route.method,params:this.builder.route.params},t),b={postEvent:a=>this.postObserveMessage(s,a),removeObserver:()=>this.builder.client.offMessage(s),catch:a=>(r=a,{postEvent:b.postEvent,removeObsever:b.removeObserver})};return b}postObserveMessage(e,r){e.params=r,this.builder.client.postMessage(e)}async run(e){return(await this.builder.client.postReturn(this.builder.route.context,this.builder.route.method,e)).returnData}static instanceBasic(e,r){const t=new I(r,e);return new k(t)}}class N{constructor(){u(this,"reactIDs",[])}onUpdate(e,r){const t=this.reactIDs.findIndex(s=>s.id==e);if(t==-1){this.reactIDs.push({id:e,callback:r});return}this.reactIDs[t].callback=r}offUpdate(e){this.reactIDs=this.reactIDs.filter(r=>r.id!=e)}dispatchUpdate(){this.reactIDs.map(e=>e.callback())}}return i.APIBuilder=I,i.APIRunner=k,i.ContextRoute=A,i.EventBus=B,i.EventMessage=l,i.EventRunner=x,i.ReactiveClass=N,i.isWorker=p,Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),i}({});
